<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Thesdel Secure Room</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body { background-color: #000; color: #fff; font-family: 'Plus Jakarta Sans', sans-serif; overflow: hidden; user-select: none; }
        .glass-panel { background: rgba(18, 18, 18, 0.8); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.05); }
        .option-card { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.08); border-radius: 20px; padding: 20px; transition: 0.2s; cursor: pointer; }
        .option-selected { border-color: #ff6600; background: rgba(255, 102, 0, 0.1); box-shadow: 0 0 15px rgba(255, 102, 0, 0.2); }
        .subject-pill { padding: 8px 16px; border-radius: 99px; font-size: 10px; font-weight: 800; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; white-space: nowrap; transition: 0.3s; }
        .subject-active { background: #ff6600; border-color: #ff6600; color: white; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .timer-low { color: #ef4444; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        .hidden { display: none; }
        .submit-btn { background: #ff6600; color: white; }
    </style>
</head>
<body class="p-6">

    <script>
        // BLOCK BACK BUTTON
        history.pushState(null, null, location.href);
        window.onpopstate = function () { history.go(1); };
    </script>

    <div id="loading-gate" class="fixed inset-0 z-[999] bg-black flex flex-col items-center justify-center">
        <div class="w-12 h-12 border-4 border-orange-500/20 border-t-orange-500 rounded-full animate-spin mb-4"></div>
        <p class="text-[10px] font-black uppercase tracking-[0.4em] text-gray-500">Syncing Battle Data...</p>
    </div>

    <div id="submit-confirm-modal" class="fixed inset-0 z-[500] bg-black/95 hidden items-center justify-center p-6 backdrop-blur-xl">
        <div class="glass-panel p-8 rounded-[40px] w-full max-w-sm text-center border-orange-500/30">
            <h2 class="text-xl font-black uppercase tracking-tighter">End Battle?</h2>
            <p class="text-gray-400 text-[10px] font-bold uppercase tracking-widest mt-2">Mistakes cost -2 XP. Submit now?</p>
            <div class="mt-8 flex flex-col gap-3">
                <button id="final-sub-btn" onclick="finishExam()" class="w-full bg-orange-600 text-white font-black py-5 rounded-2xl uppercase text-[10px] tracking-widest active:scale-95 transition">Submit Now</button>
                <button onclick="closeSubmitModal()" class="w-full bg-white/5 text-gray-400 font-black py-5 rounded-2xl uppercase text-[10px] tracking-widest">Reject</button>
            </div>
        </div>
    </div>

    <div id="exam-ui" class="hidden max-w-xl mx-auto h-screen flex flex-col">
        <div class="flex justify-between items-center py-6">
            <p id="timer" class="text-xl font-mono font-bold">00:00</p>
            <button onclick="openSubmitModal()" class="bg-red-600/10 text-red-500 px-6 py-3 rounded-full text-[10px] font-black uppercase tracking-widest">End Exam</button>
        </div>
        <div id="subject-tabs" class="flex gap-2 overflow-x-auto no-scrollbar pb-4"></div>
        <div class="flex-1 overflow-y-auto no-scrollbar space-y-6 pt-4">
            <span id="display-q-num" class="text-[10px] font-black text-gray-500 uppercase tracking-widest">Question 1</span>
            <p id="question-text" class="text-lg font-bold leading-relaxed"></p>
            <div id="options-container" class="space-y-3 pb-20">
                <div onclick="selectOpt('A')" id="card-A" class="option-card flex items-center gap-4">
                    <span class="w-8 h-8 rounded-full bg-white/5 flex items-center justify-center text-[10px] font-black">A</span>
                    <p id="text-A" class="text-sm font-semibold"></p>
                </div>
                <div onclick="selectOpt('B')" id="card-B" class="option-card flex items-center gap-4">
                    <span class="w-8 h-8 rounded-full bg-white/5 flex items-center justify-center text-[10px] font-black">B</span>
                    <p id="text-B" class="text-sm font-semibold"></p>
                </div>
                <div onclick="selectOpt('C')" id="card-C" class="option-card flex items-center gap-4">
                    <span class="w-8 h-8 rounded-full bg-white/5 flex items-center justify-center text-[10px] font-black">C</span>
                    <p id="text-C" class="text-sm font-semibold"></p>
                </div>
                <div onclick="selectOpt('D')" id="card-D" class="option-card flex items-center gap-4">
                    <span class="w-8 h-8 rounded-full bg-white/5 flex items-center justify-center text-[10px] font-black">D</span>
                    <p id="text-D" class="text-sm font-semibold"></p>
                </div>
            </div>
        </div>
        <div class="py-8 flex gap-3">
            <button onclick="prevQuestion()" id="prev-btn" class="flex-1 glass-panel py-5 rounded-[24px] text-[10px] font-black uppercase">Prev</button>
            <button onclick="handleNext()" id="next-btn" class="flex-[2] bg-white text-black py-5 rounded-[24px] font-black uppercase text-[10px] tracking-widest">Next</button>
        </div>
    </div>

    <div id="result-modal" class="fixed inset-0 z-[400] bg-black hidden flex-col p-8 overflow-y-auto">
        <div class="max-w-md mx-auto w-full text-center pt-10">
            <h2 class="text-4xl font-black uppercase tracking-tighter mb-8 italic">Battle Result</h2>
            <div class="grid grid-cols-2 gap-4 mb-10">
                <div class="glass-panel p-6 rounded-[32px] text-center">
                    <p class="text-[8px] text-gray-500 font-black mb-1">SCORE</p>
                    <p id="res-score" class="text-2xl font-black text-orange-500"></p>
                </div>
                <div class="glass-panel p-6 rounded-[32px] text-center">
                    <p class="text-[8px] text-gray-500 font-black mb-1">XP SHIFT</p>
                    <p id="res-xp" class="text-2xl font-black"></p>
                </div>
            </div>
            <div id="review-list" class="space-y-4 text-left mb-10"></div>
            <button onclick="window.location.replace('/cbt/index.html')" class="w-full bg-white text-black py-6 rounded-3xl font-black text-[10px] uppercase tracking-widest">Exit Arena</button>
        </div>
    </div>

    <script>
        const _URL = "https://lgfyrlfjoazedwymjpfc.supabase.co";
        const _KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxnZnlybGZqb2F6ZWR3eW1qcGZjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY1MTc1MTksImV4cCI6MjA4MjA5MzUxOX0.g1xVMCtSkkQIu2s1pkvWwxDDvgNGbikAMkyfbZJywVw";
        const sb = supabase.createClient(_URL, _KEY);

        const examId = localStorage.getItem('active_exam_id');
        let allQuestions = [], filteredQuestions = [], activeSub = "", currentIndex = 0, selectedAnswers = {}, timeLeft = 0, timerInterval, heartbeatInterval;
        let allSubjects = [];

        // --- HELPER FUNCTION FOR TIMER DISPLAY ---
        function updateTimerDisplay() {
            const timerElement = document.getElementById('timer');
            if (timerElement) {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                timerElement.innerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (timeLeft < 60) {
                    timerElement.classList.add('timer-low');
                } else {
                    timerElement.classList.remove('timer-low');
                }
            }
        }

        // --- THE GATEKEEPER WITH CHEAT DETECTION ---
        async function verifyAndLock() {
            try {
                const { data: { user } } = await sb.auth.getUser();
                if (!user || !examId) return window.location.replace('/cbt/index.html');

                // Check if already completed
                const { data: check } = await sb.from('cbt_results')
                    .select('id')
                    .eq('build_id', examId)
                    .eq('user_id', user.id)
                    .maybeSingle();

                if (check) {
                    document.body.innerHTML = `
                    <div class="h-screen flex items-center justify-center bg-black text-center p-10">
                        <div class="glass-panel p-10 rounded-[40px] border-red-500/30">
                            <h1 class="text-red-500 font-black uppercase text-xl italic">Battle Recorded</h1>
                            <p class="text-[10px] text-gray-500 mt-4 font-bold uppercase tracking-widest leading-relaxed">Retakes are prohibited to maintain the leaderboards.</p>
                            <button onclick="window.location.replace('/cbt/index.html')" class="mt-8 bg-white text-black px-10 py-4 rounded-2xl font-black text-[10px] uppercase">Back to Base</button>
                        </div>
                    </div>`;
                    return;
                }

                // Check for active session
                const { data: activeSession } = await sb.from('exam_sessions')
                    .select('*')
                    .eq('user_id', user.id)
                    .eq('build_id', examId)
                    .eq('status', 'active')
                    .maybeSingle();

                // Load questions
                const { data: qs } = await sb.from('cbt_questions')
                    .select('id, question_text, option_a, option_b, option_c, option_d, subject_tag')
                    .eq('build_id', examId);
                
                if (!qs || qs.length === 0) throw new Error("No Questions Found");
                
                allQuestions = qs;
                allSubjects = [...new Set(qs.map(q => q.subject_tag))];
                renderTabs(allSubjects);

                if (activeSession) {
                    // RESUME existing session WITH CHEAT DETECTION
                    console.log('Resuming exam session');
                    
                    // ðŸ”¥ CHEAT DETECTION: Check if they tried to farm time offline
                    const now = new Date();
                    const lastHeartbeat = new Date(activeSession.last_heartbeat);
                    const expiryDate = new Date(activeSession.expires_at);
                    
                    // Calculate how many seconds they were offline
                    const offlineSeconds = Math.floor((now - lastHeartbeat) / 1000);
                    
                    // What time SHOULD be left based on server expiry
                    const expectedTimeLeft = Math.max(0, Math.floor((expiryDate - now) / 1000));
                    
                    // What time they CLAIM to have left
                    const claimedTimeLeft = activeSession.time_remaining;
                    
                    // If they have MORE time than they should (offline farming detected)
                    if (claimedTimeLeft > expectedTimeLeft + 10) { // 10 second buffer for network
                        console.warn('âš ï¸ CHEAT DETECTED: Time manipulation');
                        
                        // Log the cheating attempt
                        await sb.from('cheat_logs').insert({
                            user_id: user.id,
                            build_id: examId,
                            offline_seconds: offlineSeconds,
                            claimed_time: claimedTimeLeft,
                            expected_time: expectedTimeLeft
                        });
                        
                        // Force the CORRECT time
                        timeLeft = expectedTimeLeft;
                        
                        // If they were offline too long (>5 minutes), auto-submit
                        if (offlineSeconds > 300) {
                            await finishExam(true);
                            return;
                        }
                    } else {
                        // No cheating detected, use their saved time
                        timeLeft = claimedTimeLeft;
                    }
                    
                    // Parse answers properly (handle both string and object)
                    if (typeof activeSession.answers === 'string') {
                        try {
                            selectedAnswers = JSON.parse(activeSession.answers);
                        } catch (e) {
                            selectedAnswers = {};
                        }
                    } else {
                        selectedAnswers = activeSession.answers || {};
                    }
                    
                    activeSub = activeSession.current_subject || allSubjects[0];
                    currentIndex = activeSession.current_index || 0;
                    
                    if (timeLeft <= 0) {
                        await finishExam(true);
                        return;
                    }
                    
                    switchSubject(activeSub);
                    currentIndex = activeSession.current_index || 0;
                    renderQuestion();
                } else {
                    // NEW exam
                    const duration = parseInt(localStorage.getItem('exam_duration')) * 60 || 1800;
                    timeLeft = duration;
                    activeSub = allSubjects[0];
                    selectedAnswers = {};
                    
                    const expiresAt = new Date(Date.now() + duration * 1000);
                    
                    // Store answers as JSON object
                    const { error: sessionError } = await sb.from('exam_sessions').insert({
                        user_id: user.id,
                        build_id: examId,
                        time_remaining: duration,
                        answers: {}, // Empty JSON object
                        current_subject: allSubjects[0],
                        current_index: 0,
                        status: 'active',
                        expires_at: expiresAt.toISOString(),
                        last_heartbeat: new Date().toISOString()
                    });
                    
                    if (sessionError) {
                        console.error('Session error:', sessionError);
                        throw sessionError;
                    }
                    
                    switchSubject(allSubjects[0]);
                }

                // Update timer display
                updateTimerDisplay();
                
                // Start heartbeat
                startHeartbeat(user.id);
                
                // Start timer
                startTimer();

                document.getElementById('loading-gate').remove();
                document.getElementById('exam-ui').classList.remove('hidden');

            } catch (err) {
                console.error('GATE ERROR:', err);
                alert("GATE ERROR: " + err.message);
                window.location.replace('/cbt/index.html');
            }
        }

        // --- HEARTBEAT ---
        function startHeartbeat(userId) {
            heartbeatInterval = setInterval(async () => {
                try {
                    // Ensure answers is a proper JSON object
                    const answersJson = typeof selectedAnswers === 'object' ? selectedAnswers : {};
                    
                    await sb.from('exam_sessions')
                        .update({ 
                            time_remaining: timeLeft,
                            answers: answersJson,
                            current_subject: activeSub,
                            current_index: currentIndex,
                            last_heartbeat: new Date().toISOString()
                        })
                        .eq('user_id', userId)
                        .eq('build_id', examId)
                        .eq('status', 'active');
                } catch (err) {
                    console.log('Heartbeat failed - will retry');
                }
            }, 2000); // Slowed to 2 seconds to reduce load
        }

        // --- TIMER ---
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            
            timerInterval = setInterval(() => {
                if (timeLeft > 0) {
                    timeLeft--;
                    updateTimerDisplay();
                    
                    if (timeLeft <= 0) {
                        finishExam();
                    }
                }
            }, 1000);
        }

        function renderTabs(subs) {
            document.getElementById('subject-tabs').innerHTML = subs.map(s => `<div id="tab-${s}" onclick="switchSubject('${s}')" class="subject-pill">${s}</div>`).join('');
        }

        function switchSubject(s) {
            activeSub = s;
            document.querySelectorAll('.subject-pill').forEach(p => p.classList.remove('subject-active'));
            document.getElementById(`tab-${s}`).classList.add('subject-active');
            filteredQuestions = allQuestions.filter(q => q.subject_tag === s);
            currentIndex = 0;
            renderQuestion();
            updateNextButton();
        }

        function renderQuestion() {
            const q = filteredQuestions[currentIndex];
            document.getElementById('display-q-num').innerText = `Question ${currentIndex + 1} of ${filteredQuestions.length}`;
            document.getElementById('question-text').innerText = q.question_text;
            document.getElementById('text-A').innerText = q.option_a;
            document.getElementById('text-B').innerText = q.option_b;
            document.getElementById('text-C').innerText = q.option_c;
            document.getElementById('text-D').innerText = q.option_d;
            document.querySelectorAll('.option-card').forEach(c => c.classList.remove('option-selected'));
            if (selectedAnswers[q.id]) document.getElementById(`card-${selectedAnswers[q.id]}`).classList.add('option-selected');
            updateNextButton();
        }

        function selectOpt(opt) { 
            selectedAnswers[filteredQuestions[currentIndex].id] = opt; 
            renderQuestion(); 
        }

        function handleNext() {
            const nextBtn = document.getElementById('next-btn');
            
            if (nextBtn.innerText === 'SUBMIT') {
                openSubmitModal();
                return;
            }
            
            if (currentIndex < filteredQuestions.length - 1) {
                currentIndex++;
                renderQuestion();
            } else {
                const currentSubIndex = allSubjects.indexOf(activeSub);
                if (currentSubIndex < allSubjects.length - 1) {
                    switchSubject(allSubjects[currentSubIndex + 1]);
                }
            }
        }

        function updateNextButton() {
            const nextBtn = document.getElementById('next-btn');
            const isLastQuestion = currentIndex === filteredQuestions.length - 1;
            const isLastSubject = allSubjects.indexOf(activeSub) === allSubjects.length - 1;
            
            if (isLastQuestion && isLastSubject) {
                nextBtn.innerText = 'SUBMIT';
                nextBtn.classList.remove('bg-white', 'text-black');
                nextBtn.classList.add('bg-orange-600', 'text-white');
            } else {
                nextBtn.innerText = 'Next';
                nextBtn.classList.remove('bg-orange-600', 'text-white');
                nextBtn.classList.add('bg-white', 'text-black');
            }
        }

        function prevQuestion() { 
            if (currentIndex > 0) { 
                currentIndex--; 
                renderQuestion(); 
            }
        }

        function openSubmitModal() { 
            document.getElementById('submit-confirm-modal').classList.replace('hidden', 'flex'); 
        }
        
        function closeSubmitModal() { 
            document.getElementById('submit-confirm-modal').classList.replace('flex', 'hidden'); 
        }

        // --- FINISH EXAM ---
        async function finishExam(autoSubmit = false) {
            const btn = document.getElementById('final-sub-btn');
            if (btn) {
                btn.disabled = true;
                btn.innerText = "UPDATING PROFILE...";
            }

            clearInterval(timerInterval);
            clearInterval(heartbeatInterval);
            
            try {
                const { data: { user } } = await sb.auth.getUser();
                
                // Get correct answers
                const { data: answers } = await sb.from('cbt_questions')
                    .select('id, correct_answer')
                    .eq('build_id', examId);
                
                let correct = 0;
                let missed = 0;
                
                for (let i = 0; i < answers.length; i++) {
                    const q = answers[i];
                    const userAnswer = selectedAnswers[q.id];
                    if (userAnswer && userAnswer === q.correct_answer) {
                        correct++;
                    } else if (userAnswer) {
                        missed++;
                    }
                }

                // Calculate XP
                const xpDelta = (correct * 10) - (missed * 2);

                // Get current XP
                const { data: profile, error: profileError } = await sb
                    .from('profile')
                    .select('xp')
                    .eq('id', user.id)
                    .single();
                
                if (profileError) throw profileError;
                
                const currentXp = Number(profile.xp) || 0;
                const newXp = Math.max(0, currentXp + xpDelta);

                // Insert result
                const { error: saveErr } = await sb
                    .from('cbt_results')
                    .insert({
                        user_id: user.id,
                        build_id: examId,
                        score: correct,
                        total_questions: allQuestions.length
                    });
                
                if (saveErr) throw saveErr;

                // Update XP
                const { error: updateErr } = await sb
                    .from('profile')
                    .update({ xp: newXp })
                    .eq('id', user.id);

                if (updateErr) throw updateErr;

                // Close session
                await sb
                    .from('exam_sessions')
                    .update({ 
                        status: 'completed',
                        time_remaining: 0,
                        answers: selectedAnswers // Save final answers
                    })
                    .eq('user_id', user.id)
                    .eq('build_id', examId)
                    .eq('status', 'active');

                // Cleanup
                localStorage.removeItem('active_exam_id');
                localStorage.removeItem('exam_duration');

                // Show results
                document.getElementById('exam-ui').classList.add('hidden');
                document.getElementById('res-score').innerText = correct + '/' + allQuestions.length;
                
                const xpDisplay = document.getElementById('res-xp');
                xpDisplay.innerText = (xpDelta > 0 ? '+' : '') + xpDelta + ' XP';
                xpDisplay.className = 'text-2xl font-black ' + (xpDelta >= 0 ? 'text-green-500' : 'text-red-500');

                document.getElementById('result-modal').classList.replace('hidden', 'flex');
                closeSubmitModal();

            } catch (err) {
                console.error('ERROR:', err);
                alert('SUBMIT ERROR: ' + err.message);
                if (btn) {
                    btn.disabled = false;
                    btn.innerText = 'Submit Now';
                }
            }
        }

        // Start the verification
        verifyAndLock();
    </script>
</body>
</html>
